import xml.etree.ElementTree as ET
import math
from typing import List, Tuple, Dict, Set
import warnings

class Edge2D:
    """Class to represent a 2D edge with its properties"""
    
    def __init__(self, edge_type: str, points: List[Tuple[float, float]], 
                 is_hidden: bool = False, view: str = None):
        """
        Initialize a 2D edge
        
        Args:
            edge_type: 'line', 'arc', or 'circle'
            points: List of points defining the edge
            is_hidden: Whether the edge is hidden (dashed line)
            view: Which view this edge belongs to ('front', 'bottom', 'left')
        """
        self.type = edge_type
        self.points = points  # List of (x, y) tuples
        self.is_hidden = is_hidden
        self.view = view
        self.feature = None  # Px, Py, Pz, I, A (to be determined)
        self.bounding_box = None  # ((min_x, min_y), (max_x, max_y))
        self.merged = False  # Flag if this edge resulted from merging
        
        # For arcs and circles, ensure we have enough points
        if edge_type == 'arc' and len(points) < 3:
            # Add midpoint for arc
            self._add_midpoint_for_arc()
        elif edge_type == 'circle' and len(points) < 4:
            # Add quarter and midpoint for circle
            self._add_points_for_circle()
    
    def _add_midpoint_for_arc(self):
        """Add a midpoint to properly define an arc"""
        if len(self.points) >= 2:
            # For simplicity, calculate a midpoint (in reality would need SVG arc parameters)
            start = self.points[0]
            end = self.points[-1]
            mid = ((start[0] + end[0]) / 2, (start[1] + end[1]) / 2)
            # Insert at position 1
            self.points = [start, mid, end]
    
    def _add_points_for_circle(self):
        """Add quarter and midpoint points for circle"""
        if len(self.points) >= 1:
            # Assuming first point is center, need radius from SVG data
            # For now, create dummy points
            center = self.points[0]
            self.points = [
                center,
                (center[0] + 1, center[1]),  # Right point (first quarter)
                (center[0], center[1] + 1),  # Top point (middle)
                (center[0] - 1, center[1])   # Left point
            ]
    
    def compute_bounding_box(self):
        """Compute axis-aligned bounding box for the edge"""
        if not self.points:
            return None
        
        xs = [p[0] for p in self.points]
        ys = [p[1] for p in self.points]
        
        min_x, max_x = min(xs), max(xs)
        min_y, max_y = min(ys), max(ys)
        
        self.bounding_box = ((min_x, min_y), (max_x, max_y))
        return self.bounding_box
    
    def determine_feature(self, view_type: str):
        """
        Determine the edge feature (Px, Py, Pz, I, or A) based on its orientation
        
        Args:
            view_type: 'front' (X,Y), 'bottom' (X,Z), or 'left' (Z,Y)
        """
        if self.type == 'arc' or self.type == 'circle':
            self.feature = 'A'
            return 'A'
        
        if len(self.points) < 2:
            self.feature = None
            return None
        
        # For lines
        start = self.points[0]
        end = self.points[-1]
        
        # Check if line is axis-aligned
        if abs(start[0] - end[0]) < 1e-9:  # Vertical line
            if view_type == 'front':
                self.feature = 'Py'  # Parallel to Y in front view
            elif view_type == 'bottom':
                self.feature = 'Pz'  # Parallel to Z in bottom view
            elif view_type == 'left':
                self.feature = 'Py'  # Parallel to Y in left view
        elif abs(start[1] - end[1]) < 1e-9:  # Horizontal line
            if view_type == 'front':
                self.feature = 'Px'  # Parallel to X in front view
            elif view_type == 'bottom':
                self.feature = 'Px'  # Parallel to X in bottom view
            elif view_type == 'left':
                self.feature = 'Pz'  # Parallel to Z in left view
        else:
            self.feature = 'I'  # Inclined line
        
        return self.feature
    
    def __repr__(self):
        return f"Edge2D(type={self.type}, feature={self.feature}, points={len(self.points)}, hidden={self.is_hidden})"


class SVG2DParser:
    """Parser for extracting 2D edges from SVG files"""
    
    def __init__(self, svg_path: str):
        """
        Initialize SVG parser
        
        Args:
            svg_path: Path to the SVG file
        """
        self.svg_path = svg_path
        self.tree = ET.parse(svg_path)
        self.root = self.tree.getroot()
        
        # Define namespaces (SVG uses namespaces)
        self.ns = {'svg': 'http://www.w3.org/2000/svg'}
        
        # Edge sets for each view
        self.front_edges = []  # Ef: (X,Y) view
        self.bottom_edges = []  # Eb: (X,Z) view
        self.left_edges = []    # El: (Z,Y) view
        
        # Vertex sets (unused in step 1 but defined per literature)
        self.Vf = set()  # Front view vertices
        self.Vb = set()  # Bottom view vertices
        self.Vl = set()  # Left view vertices
    
    def parse_svg(self):
        """Parse the SVG file and extract edges from all views"""
        # In a real implementation, we would identify different views in the SVG
        # For now, we'll parse all paths and group them into views based on position
        # or some heuristic/annotation
        
        all_paths = self.root.findall('.//svg:path', self.ns)
        all_lines = self.root.findall('.//svg:line', self.ns)
        all_circles = self.root.findall('.//svg:circle', self.ns)
        all_ellipses = self.root.findall('.//svg:ellipse', self.ns)
        
        # Parse all graphical elements
        elements = []
        elements.extend(all_paths)
        elements.extend(all_lines)
        elements.extend(all_circles)
        elements.extend(all_ellipses)
        
        for elem in elements:
            self._parse_element(elem)
        
        # After parsing, identify views based on coordinate ranges
        self._identify_views()
        
        # Process each view
        self._process_view_edges('front', self.front_edges)
        self._process_view_edges('bottom', self.bottom_edges)
        self._process_view_edges('left', self.left_edges)
        
        # Merge collinear line segments
        self.front_edges = self._merge_collinear_edges(self.front_edges)
        self.bottom_edges = self._merge_collinear_edges(self.bottom_edges)
        self.left_edges = self._merge_collinear_edges(self.left_edges)
        
        # Remove duplicates (visible and hidden lines that are coincident)
        self.front_edges = self._remove_duplicates(self.front_edges)
        self.bottom_edges = self._remove_duplicates(self.bottom_edges)
        self.left_edges = self._remove_duplicates(self.left_edges)
    
    def _parse_element(self, elem):
        """Parse an SVG element and extract edge information"""
        # Get style to determine if hidden (dashed line)
        style = elem.get('style', '')
        is_hidden = 'stroke-dasharray' in style
        
        # Parse based on element type
        tag = elem.tag.split('}')[-1]  # Remove namespace
        
        if tag == 'path':
            self._parse_path(elem, is_hidden)
        elif tag == 'line':
            self._parse_line(elem, is_hidden)
        elif tag == 'circle':
            self._parse_circle(elem, is_hidden)
        elif tag == 'ellipse':
            self._parse_ellipse(elem, is_hidden)
    
    def _parse_path(self, elem, is_hidden):
        """Parse SVG path element"""
        d = elem.get('d', '')
        if not d:
            return
        
        # Simplified path parsing - in reality would need full SVG path parsing
        # This is a simplified version that extracts line segments
        
        commands = d.replace(',', ' ').split()
        points = []
        i = 0
        
        while i < len(commands):
            cmd = commands[i]
            
            if cmd in ['M', 'm', 'L', 'l']:  # Move or line commands
                # Get coordinates (simplified)
                if i + 2 < len(commands):
                    try:
                        x = float(commands[i+1])
                        y = float(commands[i+2])
                        points.append((x, y))
                        i += 3
                    except ValueError:
                        i += 1
                else:
                    i += 1
            elif cmd in ['C', 'c', 'Q', 'q']:  # Curve commands (arcs)
                # Parse as arc
                if len(points) >= 2:
                    edge = Edge2D('arc', points, is_hidden)
                    # Add to all edges temporarily
                    self._add_to_appropriate_view(edge)
                points = []
                i += 1
            elif cmd in ['Z', 'z']:  # Close path
                if len(points) >= 2:
                    edge = Edge2D('line', points, is_hidden)
                    self._add_to_appropriate_view(edge)
                points = []
                i += 1
            else:
                i += 1
        
        # If we have points left, create an edge
        if len(points) >= 2:
            edge_type = 'line' if len(points) == 2 else 'arc'
            edge = Edge2D(edge_type, points, is_hidden)
            self._add_to_appropriate_view(edge)
    
    def _parse_line(self, elem, is_hidden):
        """Parse SVG line element"""
        try:
            x1 = float(elem.get('x1', 0))
            y1 = float(elem.get('y1', 0))
            x2 = float(elem.get('x2', 0))
            y2 = float(elem.get('y2', 0))
            
            points = [(x1, y1), (x2, y2)]
            edge = Edge2D('line', points, is_hidden)
            self._add_to_appropriate_view(edge)
        except ValueError:
            pass
    
    def _parse_circle(self, elem, is_hidden):
        """Parse SVG circle element"""
        try:
            cx = float(elem.get('cx', 0))
            cy = float(elem.get('cy', 0))
            r = float(elem.get('r', 0))
            
            # Create circle with center point
            points = [(cx, cy)]
            edge = Edge2D('circle', points, is_hidden)
            self._add_to_appropriate_view(edge)
        except ValueError:
            pass
    
    def _parse_ellipse(self, elem, is_hidden):
        """Parse SVG ellipse element (treat as arc/circle)"""
        try:
            cx = float(elem.get('cx', 0))
            cy = float(elem.get('cy', 0))
            rx = float(elem.get('rx', 0))
            ry = float(elem.get('ry', 0))
            
            points = [(cx, cy)]
            edge = Edge2D('arc', points, is_hidden)  # Treat ellipse as arc
            self._add_to_appropriate_view(edge)
        except ValueError:
            pass
    
    def _add_to_appropriate_view(self, edge):
        """Add edge to appropriate view based on position (simplified heuristic)"""
        # This is a simplified heuristic - in reality would need proper view identification
        # based on SVG structure or annotations
        
        if not edge.points:
            return
        
        # Get approximate position
        avg_x = sum(p[0] for p in edge.points) / len(edge.points)
        avg_y = sum(p[1] for p in edge.points) / len(edge.points)
        
        # Simple heuristic: divide canvas into three regions
        # In a real implementation, views would be properly identified
        if avg_x < 300:  # Left third
            self.left_edges.append(edge)
            edge.view = 'left'
        elif avg_x < 600:  # Middle third
            self.front_edges.append(edge)
            edge.view = 'front'
        else:  # Right third
            self.bottom_edges.append(edge)
            edge.view = 'bottom'
    
    def _identify_views(self):
        """Identify which edges belong to which view (front, bottom, left)"""
        # This is a placeholder - in reality, views would be identified
        # based on coordinate systems or annotations in the SVG
        
        # For now, we'll use the simple heuristic from _add_to_appropriate_view
        # and just ensure all edges have their view set
        pass
    
    def _process_view_edges(self, view_name: str, edges: List[Edge2D]):
        """Process edges for a specific view"""
        for edge in edges:
            # Compute bounding box
            edge.compute_bounding_box()
            
            # Determine feature (Px, Py, Pz, I, A)
            edge.determine_feature(view_name)
            
            # Extract vertices and add to vertex sets
            for point in edge.points:
                if view_name == 'front':
                    self.Vf.add(point)
                elif view_name == 'bottom':
                    self.Vb.add(point)
                elif view_name == 'left':
                    self.Vl.add(point)
    
    def _merge_collinear_edges(self, edges: List[Edge2D]) -> List[Edge2D]:
        """Merge collinear line segments that share vertices"""
        if not edges:
            return edges
        
        # Group edges by feature and approximate slope
        line_edges = [e for e in edges if e.type == 'line']
        non_line_edges = [e for e in edges if e.type != 'line']
        
        # Dictionary to group collinear edges
        collinear_groups = {}
        
        for edge in line_edges:
            if len(edge.points) < 2:
                continue
            
            start = edge.points[0]
            end = edge.points[-1]
            
            # Calculate line parameters
            if abs(end[0] - start[0]) < 1e-9:  # Vertical line
                key = ('vertical', start[0])
            elif abs(end[1] - start[1]) < 1e-9:  # Horizontal line
                key = ('horizontal', start[1])
            else:
                # For inclined lines, use slope and intercept
                slope = (end[1] - start[1]) / (end[0] - start[0])
                intercept = start[1] - slope * start[0]
                key = ('inclined', round(slope, 3), round(intercept, 3))
            
            if key not in collinear_groups:
                collinear_groups[key] = []
            collinear_groups[key].append(edge)
        
        # Merge edges in each collinear group
        merged_edges = non_line_edges.copy()
        
        for key, edge_group in collinear_groups.items():
            if len(edge_group) <= 1:
                merged_edges.extend(edge_group)
                continue
            
            # Sort edges along the line
            if key[0] == 'vertical':
                # Sort by y-coordinate
                edge_group.sort(key=lambda e: min(p[1] for p in e.points))
            else:
                # Sort by x-coordinate
                edge_group.sort(key=lambda e: min(p[0] for p in e.points))
            
            # Check if edges are connected (share vertices)
            current_merged = edge_group[0]
            
            for i in range(1, len(edge_group)):
                next_edge = edge_group[i]
                
                # Check if edges share a vertex (end of current matches start of next)
                current_end = current_merged.points[-1]
                next_start = next_edge.points[0]
                next_end = next_edge.points[-1]
                
                if self._points_equal(current_end, next_start, tolerance=1e-3):
                    # Merge: replace end point with next edge's end point
                    current_merged.points = current_merged.points[:-1] + next_edge.points
                    current_merged.merged = True
                elif self._points_equal(current_end, next_end, tolerance=1e-3):
                    # Merge: replace end point with next edge's start point (reversed)
                    current_merged.points = current_merged.points[:-1] + next_edge.points[::-1]
                    current_merged.merged = True
                else:
                    # Not connected, add current merged and start new
                    merged_edges.append(current_merged)
                    current_merged = next_edge
            
            merged_edges.append(current_merged)
        
        return merged_edges
    
    def _points_equal(self, p1: Tuple[float, float], p2: Tuple[float, float], 
                     tolerance: float = 1e-3) -> bool:
        """Check if two points are equal within tolerance"""
        return abs(p1[0] - p2[0]) < tolerance and abs(p1[1] - p2[1]) < tolerance
    
    def _remove_duplicates(self, edges: List[Edge2D]) -> List[Edge2D]:
        """Remove duplicate edges (visible and hidden lines that are coincident)"""
        unique_edges = []
        seen = set()
        
        for edge in edges:
            # Create a signature for the edge based on its geometry
            if not edge.points:
                continue
            
            # Normalize points (sort for consistent signature)
            normalized_points = tuple(sorted(edge.points))
            sig = (edge.type, normalized_points)
            
            if sig not in seen:
                seen.add(sig)
                unique_edges.append(edge)
            else:
                # Keep visible line over hidden line if duplicates
                for i, existing_edge in enumerate(unique_edges):
                    existing_sig = (existing_edge.type, 
                                   tuple(sorted(existing_edge.points)))
                    if existing_sig == sig and existing_edge.is_hidden and not edge.is_hidden:
                        unique_edges[i] = edge  # Replace hidden with visible
                        break
        
        return unique_edges
    
    def get_edge_sets(self) -> Tuple[List[Edge2D], List[Edge2D], List[Edge2D]]:
        """Get the three edge sets as defined in the literature (Ef, Eb, El)"""
        return self.front_edges, self.bottom_edges, self.left_edges
    
    def get_vertex_sets(self) -> Tuple[Set, Set, Set]:
        """Get the three vertex sets as defined in the literature (Vf, Vb, Vl)"""
        return self.Vf, self.Vb, self.Vl
    
    def print_summary(self):
        """Print a summary of the extracted edges"""
        print("=" * 60)
        print("2D EDGE EXTRACTION SUMMARY (Step 1)")
        print("=" * 60)
        
        print(f"\nFront View (Ef): {len(self.front_edges)} edges")
        for i, edge in enumerate(self.front_edges[:5]):  # Show first 5
            print(f"  Edge {i+1}: {edge}")
        if len(self.front_edges) > 5:
            print(f"  ... and {len(self.front_edges) - 5} more")
        
        print(f"\nBottom View (Eb): {len(self.bottom_edges)} edges")
        for i, edge in enumerate(self.bottom_edges[:5]):
            print(f"  Edge {i+1}: {edge}")
        if len(self.bottom_edges) > 5:
            print(f"  ... and {len(self.bottom_edges) - 5} more")
        
        print(f"\nLeft View (El): {len(self.left_edges)} edges")
        for i, edge in enumerate(self.left_edges[:5]):
            print(f"  Edge {i+1}: {edge}")
        if len(self.left_edges) > 5:
            print(f"  ... and {len(self.left_edges) - 5} more")
        
        print(f"\nVertex counts: Front={len(self.Vf)}, Bottom={len(self.Vb)}, Left={len(self.Vl)}")
        print("=" * 60)


def execute_step1(svg_path: str) -> SVG2DParser:
    """
    Execute Step 1: Extract 2D edges from SVG file
    
    Args:
        svg_path: Path to the SVG file
        
    Returns:
        SVG2DParser object with extracted edges and vertices
    """
    print(f"Processing SVG file: {svg_path}")
    
    try:
        parser = SVG2DParser(svg_path)
        parser.parse_svg()
        parser.print_summary()
        return parser
    except FileNotFoundError:
        print(f"Error: SVG file not found at {svg_path}")
        return None
    except ET.ParseError as e:
        print(f"Error: Failed to parse SVG file: {e}")
        return None
    except Exception as e:
        print(f"Unexpected error: {e}")
        return None


# Example usage
if __name__ == "__main__":
    # Example SVG path - replace with your actual SVG file path
    svg_file_path = "path/to/your/orthographic_drawing.svg"
    
    # For testing with a non-existent file, we'll create a dummy example
    print("Note: This is a template implementation.")
    print("For actual use, provide a valid SVG file path.")
    print("\nTo use with your SVG file:")
    print(f"1. Replace 'svg_file_path' with your actual file path")
    print("2. The parser will extract edges and classify them")
    print("3. Results will be shown in the summary")
    
    # Uncomment to run with your file:
    # parser = execute_step1(svg_file_path)
