import numpy as np
import matplotlib.pyplot as plt
from svgpathtools import svg2paths2, Line, Arc
from dataclasses import dataclass
import itertools

# =========================
# Data structure
# =========================
@dataclass
class Edge2D:
    points: list          # [(x,y), ...]
    bbox: tuple           # (xmin, ymin, xmax, ymax)
    feature: str          # Px, Py, Pz, I, A
    view: str             # F, B, L
    primitive: str        # line / arc


# =========================
# Utility functions
# =========================
def bbox_from_points(pts):
    xs = [p[0] for p in pts]
    ys = [p[1] for p in pts]
    return (min(xs), min(ys), max(xs), max(ys))

def bbox_center(b):
    return ((b[0]+b[2])/2, (b[1]+b[3])/2)

def almost_equal(a,b,eps=1e-6):
    return abs(a-b) < eps

def points_close(p,q,eps=1e-6):
    return almost_equal(p[0],q[0],eps) and almost_equal(p[1],q[1],eps)


# =========================
# Feature classification
# =========================
def classify_line(p1, p2, view, eps=1e-6):
    dx = abs(p2[0]-p1[0])
    dy = abs(p2[1]-p1[1])

    if dy < eps:
        return "Px" if view in ["F","B"] else "Pz"
    elif dx < eps:
        return "Py"
    else:
        return "I"


# =========================
# Collinear merging
# =========================
def collinear(e1, e2, eps=1e-6):
    p1,p2 = e1.points[0], e1.points[-1]
    p3,p4 = e2.points[0], e2.points[-1]

    v1 = np.array([p2[0]-p1[0], p2[1]-p1[1]])
    v2 = np.array([p4[0]-p3[0], p4[1]-p3[1]])

    if abs(np.cross(v1, v2)) > eps:
        return False

    return (
        points_close(p1,p3) or points_close(p1,p4) or
        points_close(p2,p3) or points_close(p2,p4)
    )

def merge_collinear(edges):
    merged = []
    used = set()

    for i,e in enumerate(edges):
        if i in used:
            continue

        group = [e]
        used.add(i)

        for j,f in enumerate(edges):
            if j in used:
                continue
            if e.feature == f.feature and collinear(e,f):
                group.append(f)
                used.add(j)

        pts = list(itertools.chain.from_iterable(
            [(g.points[0], g.points[-1]) for g in group]
        ))

        unique = []
        for p in pts:
            if not any(points_close(p,q) for q in unique):
                unique.append(p)

        if len(unique) >= 2:
            merged.append(
                Edge2D(
                    points=unique,
                    bbox=bbox_from_points(unique),
                    feature=e.feature,
                    view=e.view,
                    primitive="line"
                )
            )

    return merged


# =========================
# STEP-1 EXTRACTION (FIXED)
# =========================
def extract_edges_step1(svg_path):
    paths, _, _ = svg2paths2(svg_path)

    raw_edges = []
    for path in paths:
        for seg in path:
            if isinstance(seg, Line):
                pts = [(seg.start.real, seg.start.imag),
                       (seg.end.real, seg.end.imag)]
                primitive = "line"
            elif isinstance(seg, Arc):
                pm = seg.point(0.5)
                pts = [(seg.start.real, seg.start.imag),
                       (pm.real, pm.imag),
                       (seg.end.real, seg.end.imag)]
                primitive = "arc"
            else:
                continue

            raw_edges.append({
                "points": pts,
                "bbox": bbox_from_points(pts),
                "primitive": primitive
            })

    # ---- VIEW SEPARATION (KEY FIX) ----
    centers = np.array([bbox_center(e["bbox"]) for e in raw_edges])
    x_sorted = np.argsort(centers[:,0])
    clusters = np.array_split(x_sorted, 3)

    views = {"F":[], "B":[], "L":[]}
    for idxs,label in zip(clusters, ["F","B","L"]):
        for i in idxs:
            views[label].append(raw_edges[i])

    Ef, Eb, El = [], [], []

    for view,edges in views.items():
        processed = []
        for e in edges:
            pts = e["points"]
            if e["primitive"] == "line":
                feature = classify_line(pts[0], pts[-1], view)
            else:
                feature = "A"

            processed.append(
                Edge2D(
                    points=pts,
                    bbox=e["bbox"],
                    feature=feature,
                    view=view,
                    primitive=e["primitive"]
                )
            )

        lines = [e for e in processed if e.primitive=="line"]
        arcs  = [e for e in processed if e.primitive=="arc"]
        processed = merge_collinear(lines) + arcs

        if view == "F": Ef = processed
        if view == "B": Eb = processed
        if view == "L": El = processed

    return Ef, Eb, El


# =========================
# üîç VISUAL VERIFICATION
# =========================
def plot_view(edges, title):
    plt.figure(figsize=(6,6))
    for e in edges:
        xs = [p[0] for p in e.points]
        ys = [p[1] for p in e.points]
        plt.plot(xs, ys, linewidth=2)

        cx = sum(xs)/len(xs)
        cy = sum(ys)/len(ys)
        plt.text(cx, cy, f"{e.feature}", color="red", fontsize=10)

    plt.title(title)
    plt.axis("equal")
    plt.grid(True)
    plt.show()


# =========================
# üîÅ RUN + VERIFY
# =========================
if __name__ == "__main__":
    svg_path = "your_file.svg"   # <<< CHANGE THIS

    Ef, Eb, El = extract_edges_step1(svg_path)

    print("Front View edges:", len(Ef))
    print("Bottom View edges:", len(Eb))
    print("Left View edges:", len(El))

    plot_view(Ef, "Front View (X‚ÄìY)")
    plot_view(Eb, "Bottom View (X‚ÄìZ)")
    plot_view(El, "Left View (Z‚ÄìY)")
