from svgpathtools import svg2paths2, Line, Arc
from dataclasses import dataclass
import matplotlib.pyplot as plt
import math

# =========================
# Data structure
# =========================
@dataclass
class Edge2D:
    points: list
    feature: str
    view: str
    primitive: str


# =========================
# Helpers
# =========================
def parse_svg_length(val):
    return float(''.join(c for c in val if c.isdigit() or c == '.'))

def detect_view(cx, cy, W, H):
    if cx < W/2 and cy < H/2:
        return "F"      # Front
    elif cx < W/2 and cy >= H/2:
        return "B"      # Bottom
    else:
        return "L"      # Left

def classify_line(p1, p2, view, eps=1e-6):
    dx = abs(p2[0] - p1[0])
    dy = abs(p2[1] - p1[1])

    if dy < eps:
        return "Px" if view in ["F", "B"] else "Pz"
    elif dx < eps:
        return "Py"
    else:
        return "Inclined"

def are_collinear(e1, e2, tol=1e-6):
    p1, p2 = e1.points[0], e1.points[-1]
    p3, p4 = e2.points[0], e2.points[-1]

    def cross(a, b, c):
        return abs((b[0]-a[0])*(c[1]-a[1]) -
                   (b[1]-a[1])*(c[0]-a[0]))

    return cross(p1, p2, p3) < tol and cross(p1, p2, p4) < tol

def merge_edges(edges):
    merged = []
    used = [False]*len(edges)

    for i, e in enumerate(edges):
        if used[i]:
            continue

        pts = e.points[:]
        for j in range(i+1, len(edges)):
            if used[j]:
                continue
            if (e.feature == edges[j].feature and
                are_collinear(e, edges[j])):
                pts += edges[j].points
                used[j] = True

        xs = [p[0] for p in pts]
        ys = [p[1] for p in pts]
        new_edge = Edge2D(
            points=[(min(xs), min(ys)), (max(xs), max(ys))],
            feature=e.feature,
            view=e.view,
            primitive=e.primitive
        )
        merged.append(new_edge)

    return merged


# =========================
# Step-1 Extraction
# =========================
def extract_edges(svg_path):
    paths, _, svg_attr = svg2paths2(svg_path)

    W = parse_svg_length(svg_attr["width"])
    H = parse_svg_length(svg_attr["height"])

    views = {"F": [], "B": [], "L": []}

    for path in paths:
        for seg in path:
            if isinstance(seg, Line):
                pts = [(seg.start.real, seg.start.imag),
                       (seg.end.real, seg.end.imag)]
                primitive = "line"
            elif isinstance(seg, Arc):
                pm = seg.point(0.5)
                pts = [(seg.start.real, seg.start.imag),
                       (pm.real, pm.imag),
                       (seg.end.real, seg.end.imag)]
                primitive = "arc"
            else:
                continue

            cx = sum(p[0] for p in pts)/len(pts)
            cy = sum(p[1] for p in pts)/len(pts)
            view = detect_view(cx, cy, W, H)

            feature = classify_line(pts[0], pts[-1], view) if primitive == "line" else "Arc"

            views[view].append(
                Edge2D(pts, feature, view, primitive)
            )

    # merge collinear lines per view
    for v in views:
        lines = [e for e in views[v] if e.primitive == "line"]
        arcs  = [e for e in views[v] if e.primitive == "arc"]
        views[v] = merge_edges(lines) + arcs

    return views


# =========================
# Verification Plot
# =========================
def plot_view(edges, title):
    plt.figure()
    for e in edges:
        xs = [p[0] for p in e.points]
        ys = [p[1] for p in e.points]
        plt.plot(xs, ys, linewidth=2)
        cx = sum(xs)/len(xs)
        cy = sum(ys)/len(ys)
        plt.text(cx, cy, e.feature, fontsize=9, color="red")
    plt.title(title)
    plt.axis("equal")
    plt.grid(True)
    plt.show()


# =========================
# RUN
# =========================
svg_path = r"YOUR_SVG_PATH_HERE.svg"

views = extract_edges(svg_path)

plot_view(views["F"], "Front View (X–Y)")
plot_view(views["B"], "Bottom View (X–Z)")
plot_view(views["L"], "Left View (Z–Y)")
