import xml.etree.ElementTree as ET
from svgpathtools import svg2paths, Line, Arc, CubicBezier, QuadraticBezier
import matplotlib.pyplot as plt
import numpy as np

# =========================
# INPUT SVG FILE
# =========================
svg_file = r"C:\Users\91936\Downloads\reconstruction_dataset\reconstruction_dataset\2_ABC\original_data\drawings_svg\00000904.svg"

# =========================
# STEP 1: LOAD SVG
# =========================
paths, attributes = svg2paths(svg_file)

# =========================
# STEP 2: EXTRACT ALL EDGES
# =========================
edges = []

for path in paths:
    for seg in path:
        edge = {}
        edge["type"] = type(seg).__name__
        edge["start"] = (seg.start.real, seg.start.imag)
        edge["end"] = (seg.end.real, seg.end.imag)

        if isinstance(seg, Line):
            edge["geom"] = "LINE"

        elif isinstance(seg, Arc):
            edge["geom"] = "ARC"
            edge["center"] = (seg.center.real, seg.center.imag)
            edge["radius"] = seg.radius

        elif isinstance(seg, (CubicBezier, QuadraticBezier)):
            edge["geom"] = "CURVE"
            edge["ctrl"] = [(p.real, p.imag) for p in seg.bpoints()]

        edges.append(edge)

# =========================
# STEP 3: VIEW EXTRACTION BY POSITION
# =========================
all_x = []
for e in edges:
    all_x.extend([e["start"][0], e["end"][0]])

xmin, xmax = min(all_x), max(all_x)
width = xmax - xmin

front_x = xmin + 0.33 * width
bottom_x = xmin + 0.66 * width

def assign_view(edge):
    cx = 0.5 * (edge["start"][0] + edge["end"][0])
    if cx < front_x:
        return "FRONT"
    elif cx < bottom_x:
        return "BOTTOM"
    else:
        return "LEFT"

for e in edges:
    e["view"] = assign_view(e)

# =========================
# STEP 4: VERTICES & BOUNDING BOXES
# =========================
def compute_bbox(points):
    xs = [p[0] for p in points]
    ys = [p[1] for p in points]
    return {
        "ul": (min(xs), min(ys)),
        "lr": (max(xs), max(ys))
    }

for e in edges:
    pts = [e["start"], e["end"]]

    if e["geom"] != "LINE":
        if "ctrl" in e:
            pts += e["ctrl"]
        if "center" in e:
            pts.append(e["center"])

    e["vertices"] = pts
    e["bbox"] = compute_bbox(pts)

# =========================
# STEP 5: FEATURE CLASSIFICATION
# =========================
EPS = 1e-3

def classify_feature(edge):
    if edge["geom"] != "LINE":
        return "A"

    (x1, y1), (x2, y2) = edge["start"], edge["end"]
    dx = abs(x2 - x1)
    dy = abs(y2 - y1)

    if dx < EPS and dy < EPS:
        return "Pt"
    if dy < EPS:
        return "Px"
    if dx < EPS:
        return "Py"
    return "I"

for e in edges:
    e["feature"] = classify_feature(e)

# =========================
# STEP 6: GROUP EDGES BY VIEW
# =========================
Ef = [e for e in edges if e["view"] == "FRONT"]
Eb = [e for e in edges if e["view"] == "BOTTOM"]
El = [e for e in edges if e["view"] == "LEFT"]

# =========================
# STEP 7: CONSOLE VERIFICATION
# =========================
for v, group in zip(["FRONT", "BOTTOM", "LEFT"], [Ef, Eb, El]):
    print(f"\n========== {v} VIEW ==========")
    for i, e in enumerate(group):
        print(f"{i}: geom={e['geom']}, feature={e['feature']}, bbox={e['bbox']}")

# =========================
# STEP 8: SEPARATE VIEW PLOTS
# =========================
def plot_view(edges, title):
    plt.figure(figsize=(6, 6))
    for e in edges:
        x = [e["start"][0], e["end"][0]]
        y = [e["start"][1], e["end"][1]]
        plt.plot(x, y)

    plt.gca().invert_yaxis()
    plt.gca().set_aspect("equal")
    plt.title(title)
    plt.show()

plot_view(Ef, "Front View (X–Y)")
plot_view(Eb, "Bottom View (X–Z projection in SVG)")
plot_view(El, "Left View (Z–Y projection in SVG)")

# =========================
# FINAL SUMMARY
# =========================
print("\n========== SUMMARY ==========")
print(f"Total edges: {len(edges)}")
print(f"Front view edges: {len(Ef)}")
print(f"Bottom view edges: {len(Eb)}")
print(f"Left view edges: {len(El)}")
