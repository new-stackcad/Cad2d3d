from svgpathtools import svg2paths2, Line, Arc
from dataclasses import dataclass
import math

@dataclass
class Edge2D:
    points: list
    bbox: tuple
    feature: str
    view: str
    primitive: str

def bounding_box(points):
    xs = [p[0] for p in points]
    ys = [p[1] for p in points]
    return ((min(xs), max(ys)), (max(xs), min(ys)))

def classify_line(p1, p2, view, eps=1e-6):
    dx = abs(p2[0] - p1[0])
    dy = abs(p2[1] - p1[1])

    if dy < eps:
        return "Px" if view in ["F","B"] else "Pz"
    elif dx < eps:
        return "Py"
    else:
        return "I"

def detect_view(cx, cy, w, h):
    if cx < w/2 and cy < h/2:
        return "F"
    if cx < w/2 and cy > h/2:
        return "B"
    return "L"

def extract_edges(svg_path):
    paths, attrs, svg_attr = svg2paths2(svg_path)
    W, H = float(svg_attr["width"]), float(svg_attr["height"])

    E_f, E_b, E_l = [], [], []

    for path in paths:
        for seg in path:
            pts = []
            primitive = None

            if isinstance(seg, Line):
                p1 = (seg.start.real, seg.start.imag)
                p2 = (seg.end.real, seg.end.imag)
                pts = [p1, p2]
                primitive = "line"

            elif isinstance(seg, Arc):
                p1 = (seg.start.real, seg.start.imag)
                p2 = (seg.end.real, seg.end.imag)
                pm = seg.point(0.5)
                pts = [p1, (pm.real, pm.imag), p2]
                primitive = "arc"

            else:
                continue

            cx = sum(p[0] for p in pts) / len(pts)
            cy = sum(p[1] for p in pts) / len(pts)
            view = detect_view(cx, cy, W, H)

            if primitive == "line":
                feature = classify_line(pts[0], pts[-1], view)
            else:
                feature = "A"

            bbox = bounding_box(pts)
            edge = Edge2D(pts, bbox, feature, view, primitive)

            if view == "F":
                E_f.append(edge)
            elif view == "B":
                E_b.append(edge)
            else:
                E_l.append(edge)

    return E_f, E_b, E_l
