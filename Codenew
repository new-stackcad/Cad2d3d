import xml.etree.ElementTree as ET
from svgpathtools import parse_path
from shapely.geometry import box
import numpy as np
from sklearn.cluster import KMeans
import copy

SVG_FILE = "input.svg"   # your original svg
OUTPUT_PREFIX = "view"   # view_1.svg, view_2.svg, view_3.svg

# ----------------------------------------------------
# Compute bounding box of an SVG element
# ----------------------------------------------------
def element_bbox(elem):
    tag = elem.tag.split('}')[-1]

    if tag == "path":
        path = parse_path(elem.attrib.get("d"))
        xmin, xmax, ymin, ymax = path.bbox()
        return box(xmin, ymin, xmax, ymax)

    elif tag == "line":
        x1, y1 = float(elem.attrib["x1"]), float(elem.attrib["y1"])
        x2, y2 = float(elem.attrib["x2"]), float(elem.attrib["y2"])
        return box(min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2))

    elif tag == "rect":
        x = float(elem.attrib["x"])
        y = float(elem.attrib["y"])
        w = float(elem.attrib["width"])
        h = float(elem.attrib["height"])
        return box(x, y, x + w, y + h)

    elif tag in ["circle", "ellipse"]:
        cx = float(elem.attrib["cx"])
        cy = float(elem.attrib["cy"])
        rx = float(elem.attrib.get("rx", elem.attrib.get("r")))
        ry = float(elem.attrib.get("ry", elem.attrib.get("r")))
        return box(cx - rx, cy - ry, cx + rx, cy + ry)

    elif tag in ["polyline", "polygon"]:
        points = np.array([
            list(map(float, p.split(",")))
            for p in elem.attrib["points"].strip().split()
        ])
        xmin, ymin = points.min(axis=0)
        xmax, ymax = points.max(axis=0)
        return box(xmin, ymin, xmax, ymax)

    return None

# ----------------------------------------------------
# Parse SVG
# ----------------------------------------------------
tree = ET.parse(SVG_FILE)
root = tree.getroot()
ns = {"svg": "http://www.w3.org/2000/svg"}

elements = []
centroids = []

for elem in root.findall(".//*"):
    bbox = element_bbox(elem)
    if bbox:
        elements.append((elem, bbox))
        centroids.append(bbox.centroid.coords[0])

centroids = np.array(centroids)

# ----------------------------------------------------
# Cluster into 3 views using spatial position
# ----------------------------------------------------
kmeans = KMeans(n_clusters=3, random_state=0).fit(centroids)
labels = kmeans.labels_

clusters = {i: [] for i in range(3)}
for (elem, bbox), label in zip(elements, labels):
    clusters[label].append((elem, bbox))

# ----------------------------------------------------
# Write each cluster as a separate SVG
# ----------------------------------------------------
for idx, cluster in clusters.items():
    new_root = copy.deepcopy(root)

    # Remove all original graphic elements
    for elem in new_root.findall(".//*"):
        if elem.tag.split('}')[-1] in [
            "path", "line", "rect", "circle",
            "ellipse", "polyline", "polygon"
        ]:
            parent = elem.getparent() if hasattr(elem, "getparent") else None
            if parent is not None:
                parent.remove(elem)

    # Add only cluster elements
    for elem, _ in cluster:
        new_root.append(copy.deepcopy(elem))

    ET.ElementTree(new_root).write(
        f"{OUTPUT_PREFIX}_{idx+1}.svg",
        encoding="utf-8",
        xml_declaration=True
    )

print("âœ… Three SVG views successfully separated.")

pip install svgpathtools shapely scikit-learn
